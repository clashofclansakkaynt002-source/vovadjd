<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Striker: Mobile Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #0ff;
            /* Забороняємо виділення та жести браузера */
            touch-action: none;
            -webkit-touch-callout: none;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3;
            border: 2px solid #1a1a2e;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }

        canvas { 
            display: block; 
            background: #000; 
            width: 100%; 
            height: 100%; 
        }

        .ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            transition: 0.5s;
        }

        h1 { font-size: 8vw; max-size: 60px; margin: 0; text-shadow: 0 0 20px #0ff; color: #fff; text-align: center; }
        p { font-size: 4vw; max-size: 20px; letter-spacing: 3px; animation: blink 1.5s infinite; }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .score-board {
            position: absolute; top: 10px; width: 100%;
            text-align: center; font-size: 18px; pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
        }

        #message {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 15vw; font-weight: 900;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            z-index: 110;
        }

        #message.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="score-board">SCORE: <span id="score">0</span> | SHOTS: <span id="shots">0</span></div>
    
    <div id="start-screen" class="ui-overlay">
        <h1>NEON STRIKER</h1>
        <p>TAP TO START</p>
    </div>

    <div id="message">GOAL!</div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const message = document.getElementById('message');

    // Фіксована внутрішня роздільна здатність для розрахунків
    canvas.width = 800;
    canvas.height = 600;

    let active = false;
    let state = 'aiming';
    let score = 0;
    let shots = 0;
    let shake = 0;

    let ball = { x: 400, y: 520, z: 1, r: 18, vx: 0, vy: 0 };
    let keeper = { x: 400, y: 220, w: 70, h: 100 };
    let goal = { left: 240, right: 560, top: 160, bottom: 280 };
    
    let aimAngle = -Math.PI/2;
    let aimDir = 0.04;
    let power = 0;
    let powerDir = 3;
    let particles = [];
    let trail = [];

    // Функція обробки вводу (працює і для миші, і для тачу)
    function handleInput(e) {
        e.preventDefault(); // Запобігає зуму та скролу
        
        if (!active) {
            active = true;
            startScreen.style.opacity = '0';
            setTimeout(() => startScreen.style.display = 'none', 500);
            return;
        }

        if (state === 'aiming') {
            state = 'powering';
        } else if (state === 'powering') {
            state = 'shooting';
            ball.vx = Math.cos(aimAngle) * (power/5 + 2);
            ball.vy = Math.sin(aimAngle) * (power/5 + 2);
        }
    }

    // Слухаємо і тач, і клік
    window.addEventListener('touchstart', handleInput, { passive: false });
    window.addEventListener('mousedown', (e) => {
        if (e.button === 0) handleInput(e);
    });

    function createExplosion(x, y, color) {
        for(let i=0; i<30; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*15,
                vy: (Math.random()-0.5)*15,
                life: 1,
                color: color
            });
        }
    }

    function update() {
        if (!active) return;

        if (shake > 0) shake *= 0.9;

        if (state === 'aiming') {
            aimAngle += aimDir;
            if (aimAngle > -Math.PI/2 + 0.6 || aimAngle < -Math.PI/2 - 0.6) aimDir *= -1;
        } 
        else if (state === 'powering') {
            power += powerDir;
            if (power > 100 || power < 0) powerDir *= -1;
        }
        else if (state === 'shooting') {
            trail.push({x: ball.x, y: ball.y, z: ball.z});
            if (trail.length > 10) trail.shift();

            ball.x += ball.vx;
            ball.y += ball.vy;
            ball.vy += 0.25; 
            ball.z -= 0.015;

            let moveSpeed = 0.12;
            keeper.x += (ball.x - keeper.x) * moveSpeed;

            if (ball.z <= 0.5) {
                checkLogic();
            }
        }

        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        });
    }

    function checkLogic() {
        state = 'resetting';
        shots++;
        
        let inGoal = ball.x > goal.left && ball.x < goal.right && ball.y > goal.top && ball.y < goal.bottom;
        let caught = Math.abs(ball.x - keeper.x) < keeper.w/2 && Math.abs(ball.y - keeper.y) < keeper.h/2;

        if (caught) {
            triggerMessage("SAVED!", "#f33");
            createExplosion(ball.x, ball.y, "#f33");
            shake = 10;
        } else if (inGoal) {
            score++;
            triggerMessage("GOAL!!!", "#3f3");
            createExplosion(ball.x, ball.y, "#3f3");
            shake = 25;
        } else {
            triggerMessage("MISS", "#777");
        }

        document.getElementById('score').innerText = score;
        document.getElementById('shots').innerText = shots;
        setTimeout(reset, 2000);
    }

    function triggerMessage(txt, col) {
        message.innerText = txt;
        message.style.color = col;
        message.style.textShadow = `0 0 30px ${col}`;
        message.classList.add('active');
    }

    function reset() {
        state = 'aiming';
        ball = { x: 400, y: 520, z: 1, r: 18, vx: 0, vy: 0 };
        trail = [];
        power = 0;
        message.classList.remove('active');
    }

    function draw() {
        ctx.save();
        if (shake > 0.5) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
        
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, 800, 600);

        // Сітка
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        for(let i=0; i<800; i+=50) {
            ctx.beginPath(); ctx.moveTo(i, 600); ctx.lineTo(400+(i-400)*0.2, goal.bottom); ctx.stroke();
        }

        // Ворота
        ctx.shadowBlur = 15; ctx.shadowColor = '#0ff';
        ctx.strokeStyle = '#0ff'; ctx.lineWidth = 5;
        ctx.strokeRect(goal.left, goal.top, goal.right-goal.left, goal.bottom-goal.top);

        // Воротар
        ctx.shadowColor = '#f0f';
        ctx.fillStyle = '#f0f';
        ctx.fillRect(keeper.x - keeper.w/2, keeper.y - keeper.h/2, keeper.w, keeper.h);

        // Слід
        trail.forEach((t, i) => {
            ctx.globalAlpha = i/10;
            ctx.fillStyle = '#0ff';
            ctx.beginPath(); ctx.arc(t.x, t.y, ball.r * t.z, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        // М'яч
        ctx.shadowColor = '#fff'; ctx.shadowBlur = 20;
        ctx.fillStyle = '#fff';
        let currentR = Math.max(0, ball.r * ball.z);
        ctx.beginPath(); ctx.arc(ball.x, ball.y, currentR, 0, Math.PI*2); ctx.fill();

        // UI стрілка та шкала
        if (state === 'aiming' || state === 'powering') {
            ctx.shadowBlur = 0;
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            ctx.lineTo(ball.x + Math.cos(aimAngle)*120, ball.y + Math.sin(aimAngle)*120);
            ctx.stroke();
            ctx.setLineDash([]);

            // Шкала сили (адаптована під бік екрана)
            ctx.fillStyle = '#222';
            ctx.fillRect(740, 350, 20, 200);
            ctx.fillStyle = `hsl(${120-power}, 100%, 50%)`;
            ctx.fillRect(740, 550, 20, -power*2);
        }

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
        });

        ctx.restore();
    }

    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }

    animate();
</script>

</body>
</html>
